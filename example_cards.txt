Слайсы, отличие от массива - Слайсы это динамические структуры, построенные поверх массивов. Массив имеет фиксированный размер и не может быть изменён. Слайс хранит указатель на массив, его длину и вместимость. При добавлении элементов может выделяться новый массив.
Как передаются параметры функции в Go? А мапа? - Параметры передаются по значению. Однако слайсы, мапы и указатели содержат ссылки, поэтому изменения затрагивают оригинальные данные. Мапы передаются по "заголовку", и изменения отражаются на оригинале.
Как работает append при разных значениях len и cap? - Если len < cap, элемент добавляется в тот же массив. Если len == cap, создаётся новый массив, вдвое больший, старые элементы копируются, добавляется новый, и возвращается новый слайс.
Как работает мапа? - Мапа — это хеш-таблица, хеширует ключи в корзины. Позволяет быстро добавлять, удалять и искать значения. Не потокобезопасна и не гарантирует порядок ключей.
Как сделать сет из мапы? - Сет реализуется через map[T]struct{}. Ключи — элементы сета, struct{} — пустая структура, не занимающая памяти. Проверка наличия: _, exists := set[key].
Что такое хеш-функция? Как резолвятся и предотвращаются коллизии? - Хеш-функция превращает ключ в число. Коллизии решаются через цепочки или открытое хеширование. Для минимизации используются хорошие хеш-функции и увеличение числа корзин.
Интерфейс Error. Как надо работать с ошибками? - Интерфейс error содержит метод Error() string. Ошибки всегда проверяются через if err != nil. Можно оборачивать ошибки с контекстом и использовать errors.Is/As для анализа.
Что такое каналы, какие виды, для чего? Запись и чтение из закрытых каналов. Аксиомы каналов. - Каналы — средство синхронизации между горутинами. Бывают буферные и безбуферные. Чтение из закрытого канала возвращает ноль и ok=false. Запись в закрытый канал вызывает панику.
Мьютексы, вейт-группы, RWMutex, как создать и использовать, зачем нужны? - sync.Mutex — для взаимного исключения. RWMutex — позволяет несколько читателей, но одного писателя. WaitGroup — для ожидания завершения нескольких горутин.
Что такое sync.Pool, пример использования? - sync.Pool хранит переиспользуемые объекты. Пример: bytes.Buffer для JSON-парсинга. Позволяет снизить нагрузку на GC.
sync.Map и его использование, в чем отличие от мапы с мьютексом? - sync.Map потокобезопасна и оптимизирована под частые чтения. Не требует мьютексов. Но хуже при частых записях и не имеет прямого доступа к ключам.
errgroup — что такое, как использовать? - errgroup.Group позволяет запускать горутины с возвратом первой ошибки. Используется как WaitGroup, но с обработкой ошибок и возможностью отмены через контекст.
Как работает планировщик? - Планировщик Go распределяет горутины между системными потоками. Учитывает блокировки, тяжёлые вычисления и старается эффективно использовать CPU.
Как работает garbage collector? - GC Go использует mark-and-sweep. Работает параллельно, запускается при росте памяти или через GOGC. Автоматически удаляет неиспользуемые объекты.
Что такое контекст? Как использовать? - context.Context — инструмент отмены операций, установки таймаутов и передачи значений. Используется для управления жизненным циклом запросов и горутин.
Как сделать graceful shutdown? - Слушается сигнал завершения, инициализируется context с таймаутом, вызывается shutdown у сервера, ожидается завершение текущих операций.
Что такое padding/alignment в структурах в Go? - Go выравнивает поля структур для оптимизации доступа. Мелкие поля лучше располагать после больших, чтобы минимизировать padding и экономить память.
Интерфейсы, как реализованы, для чего используются? - Интерфейс — контракт на наличие методов. Внутри хранится указатель на данные и таблица методов. Обеспечивают полиморфизм и гибкость кода.
Типизированный nil - nil с типом (например, *int или интерфейс) не равен просто nil. Это может вызвать неожиданное поведение. Лучше проверять явно через x == nil.
Какие использовал логгеры? Какие использовал линтеры? - Логгеры: log, zap, logrus. Линтеры: golint, staticcheck, golangci-lint. Используются для логирования и автоматической проверки кода.
Lock-free структуры данных в Go? - Lock-free структуры используют sync/atomic вместо мьютексов. Позволяют выполнять атомарные операции без блокировок. Хорошо подходят для счётчиков и флагов.
